import org.gradle.nativeplatform.platform.internal.DefaultNativePlatform

plugins {
    id 'groovy'
    id 'cpp'
}

apply plugin: ReleasePlugin

versions {
    nextVersion = '0.20'
    nextSnapshot = '1'
}

allprojects {
    apply plugin: 'java'

    repositories {
        jcenter()
    }

    group = 'net.rubygrapefruit'

    sourceCompatibility = 1.5
    targetCompatibility = 1.5
}

dependencies {
    testImplementation 'org.codehaus.groovy:groovy-all:2.4.1'
    testImplementation 'org.spockframework:spock-core:1.0-groovy-2.4'
}

boolean onlyPrimaryVariants = project.hasProperty("onlyPrimaryVariants")

def nativeHeadersDir = file("$buildDir/nativeHeaders")

task nativeHeaders {
    def outputFile = file("$nativeHeadersDir/native.h")
    def classes = [
            'net.rubygrapefruit.platform.internal.jni.NativeLibraryFunctions',
            'net.rubygrapefruit.platform.internal.jni.PosixFileFunctions',
            'net.rubygrapefruit.platform.internal.jni.PosixFileSystemFunctions',
            'net.rubygrapefruit.platform.internal.jni.PosixProcessFunctions',
            'net.rubygrapefruit.platform.internal.jni.PosixTerminalFunctions',
            'net.rubygrapefruit.platform.internal.jni.TerminfoFunctions',
            'net.rubygrapefruit.platform.internal.jni.WindowsConsoleFunctions',
            'net.rubygrapefruit.platform.internal.jni.WindowsHandleFunctions',
            'net.rubygrapefruit.platform.internal.jni.WindowsRegistryFunctions',
            'net.rubygrapefruit.platform.internal.jni.WindowsFileFunctions',
            'net.rubygrapefruit.platform.internal.jni.PosixTypeFunctions',
            'net.rubygrapefruit.platform.internal.jni.MemoryFunctions',
            'net.rubygrapefruit.platform.internal.jni.OsxMemoryFunctions',
            'net.rubygrapefruit.platform.internal.jni.OsxFileEventFunctions'
    ]
    inputs.files sourceSets.main.output
    inputs.property('classes', classes)
    outputs.file outputFile
    doLast {
        outputFile.parentFile.mkdirs()
        exec {
            executable org.gradle.internal.jvm.Jvm.current().getExecutable('javah')
            args '-o', outputFile
            args '-classpath', sourceSets.main.output.classesDirs.asPath
            args classes
        }
    }
}

javadoc {
    exclude '**/internal/**'
}

task sourceZip(type: Jar) {
    from sourceSets.main.allSource
    classifier = 'sources'
}

task javadocZip(type: Jar) {
    from javadoc
    classifier = 'javadoc'
}

task emptyZip(type: Jar) {
    classifier = 'empty'
}

def variantNames = new LinkedHashSet()

// Using internal classes here to make this simple
def os = new DefaultNativePlatform("current").operatingSystem
def arch = new DefaultNativePlatform("current").architecture
def ncursesVersion = inferNCursesVersion(os)

model {
    platforms {
        osx_amd64 {
            architecture "amd64"
            operatingSystem "osx"
        }
        linux_i386 {
            architecture "i386"
            operatingSystem "linux"
        }
        linux_i386_ncurses5 {
            architecture "i386"
            operatingSystem "linux"
        }
        linux_i386_ncurses6 {
            architecture "i386"
            operatingSystem "linux"
        }
        linux_amd64 {
            architecture "amd64"
            operatingSystem "linux"
        }
        linux_amd64_ncurses5 {
            architecture "amd64"
            operatingSystem "linux"
        }
        linux_amd64_ncurses6 {
            architecture "amd64"
            operatingSystem "linux"
        }
        linux_aarch64 {
            architecture "aarch64"
            operatingSystem "linux"
        }
        linux_aarch64_ncurses5 {
            architecture "aarch64"
            operatingSystem "linux"
        }
        linux_aarch64_ncurses6 {
            architecture "aarch64"
            operatingSystem "linux"
        }
        windows_i386 {
            architecture "i386"
            operatingSystem "windows"
        }
        windows_amd64 {
            architecture "amd64"
            operatingSystem "windows"
        }
        windows_i386_min {
            architecture "i386"
            operatingSystem "windows"
        }
        windows_amd64_min {
            architecture "amd64"
            operatingSystem "windows"
        }
        freebsd_i386_libcpp {
            architecture "i386"
            operatingSystem "freebsd"
        }
        freebsd_i386_libstdcpp {
            architecture "i386"
            operatingSystem "freebsd"
        }
        freebsd_amd64_libcpp {
            architecture "amd64"
            operatingSystem "freebsd"
        }
        freebsd_amd64_libstdcpp {
            architecture "amd64"
            operatingSystem "freebsd"
        }
    }

    toolChains {
        gcc(Gcc) {
            // The core Gradle toolchain for gcc only targets x86 and x86_64 out of the box.
            // https://github.com/gradle/gradle/blob/36614ee523e5906ddfa1fed9a5dc00a5addac1b0/subprojects/platform-native/src/main/java/org/gradle/nativeplatform/toolchain/internal/gcc/AbstractGccCompatibleToolChain.java
            target("linux_aarch64")
            target("linux_aarch64_ncurses5")
            target("linux_aarch64_ncurses6")

            eachPlatform {
                // Use GCC to build for libstdc++ on FreeBSD
                if (platform.operatingSystem.freeBSD) {
                    if (platform.name.contains('libstdcpp')) {
                        cCompiler.executable = 'cc'
                        cppCompiler.executable = 'c++'
                        linker.executable = 'c++'
                    } else {
                        // Use a dummy so that GCC is not selected
                        cCompiler.executable = 'dummy'
                        cppCompiler.executable = 'dummy'
                        objcCompiler.executable = 'dummy'
                        objcppCompiler.executable = 'dummy'
                        assembler.executable = 'dummy'
                        linker.executable = 'dummy'
                        staticLibArchiver.executable = 'dummy'
                    }
                }
            }
        }
        clang(Clang) {
            eachPlatform {
                // Use Clang to build for libc++ on FreeBSD
                if (platform.operatingSystem.freeBSD) {
                    if (platform.name.contains('libcpp')) {
                        cCompiler.executable = 'cc'
                        cppCompiler.executable = 'c++'
                        linker.executable = 'c++'
                    } else {
                        // Use a dummy so that Clang is not selected
                        cCompiler.executable = 'dummy'
                        cppCompiler.executable = 'dummy'
                        objcCompiler.executable = 'dummy'
                        objcppCompiler.executable = 'dummy'
                        assembler.executable = 'dummy'
                        linker.executable = 'dummy'
                        staticLibArchiver.executable = 'dummy'
                    }
                }
            }
        }
        visualCpp(VisualCpp)
    }

    components {
        nativePlatform(NativeLibrarySpec) {
            baseName 'native-platform'
            // TODO - this should be the default. Figure out why this is not working
            $.platforms.each { p ->
                if (p.name.contains("ncurses")) {
                    return
                }
                targetPlatform p.name
            }
            sources {
                cpp {
                    source.srcDirs = ['src/shared/cpp', 'src/main/cpp']
                    exportedHeaders.srcDirs = ['src/shared/headers']
                }
            }
        }

        nativePlatformCurses(NativeLibrarySpec) {
            baseName 'native-platform-curses'
            $.platforms.each { p ->
                if (p.operatingSystem.windows) {
                    return
                }
                if (p.operatingSystem.linux && !p.name.contains("ncurses")) {
                    return
                }
                targetPlatform p.name
            }
            sources {
                cpp {
                    source.srcDirs = ['src/shared/cpp', 'src/curses/cpp']
                    exportedHeaders.srcDirs = ['src/shared/headers']
                }
            }
            binaries.all {
                if (targetPlatform.operatingSystem.linux && !targetPlatform.name.contains("curses${ncursesVersion}")) {
                    buildable = false
                }
                if (targetPlatform.operatingSystem.linux && ncursesVersion != "5") {
                    linker.args "-lncursesw"
                } else {
                    linker.args "-lcurses"
                }
            }
        }

        all {
            binaries.all {
                if (targetPlatform.operatingSystem.name in ['linux', 'freebsd'] && targetPlatform.architecture != arch) {
                    // Native plugins don't detect whether multilib support is available or not. Assume not for now
                    buildable = false
                }

                if (targetPlatform.operatingSystem.macOsX) {
                    cppCompiler.args '-I', "${org.gradle.internal.jvm.Jvm.current().javaHome}/include"
                    cppCompiler.args '-I', "${org.gradle.internal.jvm.Jvm.current().javaHome}/include/darwin"
                    cppCompiler.args '-mmacosx-version-min=10.9'
                    linker.args '-mmacosx-version-min=10.9'
                    linker.args '-framework', 'CoreServices'
                } else if (targetPlatform.operatingSystem.linux) {
                    cppCompiler.args '-I', "${org.gradle.internal.jvm.Jvm.current().javaHome}/include"
                    cppCompiler.args '-I', "${org.gradle.internal.jvm.Jvm.current().javaHome}/include/linux"
                    cppCompiler.args '-D_FILE_OFFSET_BITS=64'
                } else if (targetPlatform.operatingSystem.windows) {
                    if (name.contains("_min")) {
                        cppCompiler.define "WINDOWS_MIN"
                    } else {
                        // For NtQueryDirectoryFile
                        linker.args "ntdll.lib"
                    }
                    cppCompiler.args "-I${org.gradle.internal.jvm.Jvm.current().javaHome}/include"
                    cppCompiler.args "-I${org.gradle.internal.jvm.Jvm.current().javaHome}/include/win32"
                    linker.args "Shlwapi.lib", "Advapi32.lib"
                } else if (targetPlatform.operatingSystem.freeBSD) {
                    cppCompiler.args '-I', "${org.gradle.internal.jvm.Jvm.current().javaHome}/include"
                    cppCompiler.args '-I', "${org.gradle.internal.jvm.Jvm.current().javaHome}/include/freebsd"
                }
                cppCompiler.args "-I${nativeHeadersDir}"
            }

            binaries.withType(SharedLibraryBinarySpec) { binary ->
                def targetOs = binary.targetPlatform.operatingSystem
                def targetArch = binary.targetPlatform.architecture
                def includeVariant = !onlyPrimaryVariants || targetOs.windows || targetOs.macOsX || (targetOs.linux && targetArch.name == "x86-64" && !targetPlatform.name.contains("ncurses6"))
                if (!includeVariant) {
                    return
                }
                def variantName = targetPlatform.name.replace('_', '-')
                variantNames << variantName

                if (!buildable) {
                    return
                }

                def taskName = "jar-${variantName}"
                def nativeJar = project.tasks.findByName(taskName)
                if (nativeJar == null) {
                    nativeJar = project.tasks.create(taskName, Jar) {
                        archiveBaseName = "native-platform-$variantName"
                    }
                    artifacts {
                        runtimeElements nativeJar
                    }
                    publishing {
                        publications {
                            "$variantName"(MavenPublication) {
                                artifact(nativeJar)
                                artifact(emptyZip) {
                                    classifier = "sources"
                                }
                                artifact(emptyZip) {
                                    classifier = "javadoc"
                                }
                                groupId = project.group
                                artifactId = nativeJar.archiveBaseName.get()
                                version = project.version
                            }
                        }
                    }
                }

                binary.tasks.withType(LinkSharedLibrary) { builderTask ->
                    nativeJar.into("net/rubygrapefruit/platform/$variantName") { from builderTask.linkedFile }
                }
                project.tasks.test {
                    classpath.from nativeJar
                }
            }
        }
    }
}

tasks.withType(CppCompile) { task ->
    task.dependsOn project.tasks.nativeHeaders
}

publishing {
    publications {
        main(MavenPublication) {
            groupId = project.group
            artifactId = jar.archiveBaseName.get()
            version = project.version
            artifact jar
            artifact sourceZip
            artifact javadocZip
            pom.withXml { provider ->
                def node = provider.asNode()
                def deps = node.appendNode('dependencies')
                variantNames.each { p ->
                    def dep = deps.appendNode('dependency')
                    dep.appendNode('groupId', project.group)
                    dep.appendNode('artifactId', "native-platform-${p}")
                    dep.appendNode('version', project.version)
                    dep.appendNode('scope', 'runtime')
                }
            }
        }
    }
}

String inferNCursesVersion(def os) {
    if (!os.linux) {
        return "5"
    }
    for (def d : ["/lib", "/lib64", "/lib/x86_64-linux-gnu", "/lib/aarch64-linux-gnu"]) {
        if (new File("$d/libncurses.so.6").file) {
            return "6"
        }
        if (new File("$d/libncurses.so.5").file) {
            return "5"
        }
    }
    throw new IllegalArgumentException("Could not determine ncurses version installed on this machine.")
}
